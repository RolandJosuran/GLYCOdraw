//****************************************************************************************
// Canvas: Area for drawing
//****************************************************************************************
/* global d3 */
/* global GLYCO */

/**
 * Constructor of canvas
 *
 * @param {number} [height] SVG height
 * @param {number} [width] SVG width
 * @returns {object} draw
 * */
GLYCO.canvas = function (svg, width, height, toolbar) {

    // Toolbar property
    this.toolbar = toolbar;

    // Root for glycan
    this.root = {
        x: (width - GLYCO.sacSize) / 2,
        y: GLYCO.sacSize
        //x: width - GLYCO.sacSize,
        //y: (height - GLYCO.sacSize) / 2
    };

    // SVG properties
    this.height = height - this.toolbar.height;
    this.width = width;
    this.svg = svg;

    // domains for unzoomed chart
    this.domains = {    
        x0: [0, this.width / GLYCO.sacSize / 2],
        y0: [0, this.height / GLYCO.sacSize / 2],
        x: null,
        y: null
    };
    // set initial domains
    this.domains.x = this.domains.x || this.domains.x0;
    this.domains.y = this.domains.y || this.domains.y0;

    // set scales
    this.scales = {
        x: null,
        y: null
    };
    // ##### only for development #####
    this.setScales();

    // Add group for canvas
    this.g = this.svg.append("g")
        .attr("id", "canvas")
        .attr("transform", `translate(0, ${this.toolbar.height})`);
    this.g.append("clipPath")
        .attr("id", "canvasClipPath")
        .append("rect")
        .attr("width", this.width)
        .attr("height", this.height)
        .style("stroke", "#888")
        .style("fill", "none");


    // Glycan
    this.glycan = new GLYCO.glycan(this, this.root);
    this.glycan.render();

    return this;
}

/**
 * Set dimensions of canvas.
 * 
 * @param {string} id Optional HTML id of div that holds the svg chart.
 * @returns {object} D3PLOT chart object.
 */
GLYCO.canvas.prototype.setScales = function () {
    var canvas = this;

    // set scales
    canvas.scales.x = d3.scaleLinear().domain(canvas.domains.x).range([0, canvas.width]).nice();
    canvas.scales.y = d3.scaleLinear().domain(canvas.domains.y).range([0, canvas.height]).nice();

    return this;
};

GLYCO.canvas.prototype.click = function (event, d) {
    var canvas = this;


    // Set flag for click event
    canvas.clicked = true;

    // Generate Monosaccharid and append to data
    d.data.children.push(new GLYCO.sac(
        canvas.toolbar.selected ? canvas.toolbar.selected.sacEnum : d.data.sacEnum,
        d.data.x,
        d.data.y
    ));

    // Rerender glycan
    canvas.glycan.render();

    return canvas;
}

GLYCO.canvas.prototype.dragstarted = function (event, node) {
    var canvas = this;

    // Create new monosaccharid
    var sacObj = new GLYCO.sac(
        canvas.toolbar.selected ? canvas.toolbar.selected.sacEnum : node.data.sacEnum,
        node.data
    )

    // Render monosaccharid at start position and listen for drag
    var sac = sacObj.render(canvas.glycan.g)
        .call(d3.drag().on("start", (event, d) => canvas.dragstarted(event, d)));

    // Drag clone to glycan
    event.on("drag", (e, n) => canvas.dragged(e, n, sacObj, sac));

    // When finaly dragging has ended
    event.on("end", (e, n) => canvas.dragended(e, n, canvas, sacObj, sac) );

    return;
}

GLYCO.canvas.prototype.dragged = function (event, n, sacObj, sac) {

    // Get drag position
    sacObj.x += event.dx;
    sacObj.y += event.dy;

    // Monosaccharide follows cursor
    sac.attr("transform", `translate(${sacObj.x}, ${sacObj.y})`);
}

GLYCO.canvas.prototype.dragended = function (event, n, canvas, sacObj, sac) {

    // For vertically linked monosaccharides
    if (sacObj.linkRegion != 0) {

        // Get index of node in parents children
        let index = n.parent.data.children.indexOf(n.data);

        // Compare relative position to parent (up or down)
        if (sacObj.y < n.data.y) {

            // Check if parent has allready Fuc in direct above position
            if (n.parent.children.filter(d => d.data.linkRegion < 0 && d.data.parent == n.data).length > 0) {
                sac.remove();
                return;
            }

            // Insert above
            sacObj.linkRegion = n.parent.children[index].data.linkRegion - 1;
            n.parent.data.children.splice(index, 0, sacObj);

        } else {

            // Check if parent has allready Fuc in direct below position
            if (n.parent.children.filter(d => d.data.linkRegion > 0 && d.data.parent == n.data).length > 0) {
                sac.remove();
                return;
            }

            // Insert below
            sacObj.linkRegion = n.parent.children[index].data.linkRegion + 1;
            n.parent.data.children.splice(index + 1, 0, sacObj);

        }
    } else if (n.data.children.length == 0) {

        // If there are no children, just push at first
        n.data.children.push(sacObj);

    } else {

        // Get position for non-Fuc monosaccharides
        let inserted = false;

        // Sort from top to bottom
        n.data.children.sort((a, b) => a.y - b.y).entries();

        // Recursion for above
        function searchUp(i) {

            // Check if above position is Fuc
            if (i > 0 && n.data.children[i - 1].linkRegion < 0) {

                // Move new monosaccharid  upwards
                i--;

                // Recursively go upwards
                searchUp(i);

            }

            // Above highest Fuc
            return i;
        }

        // Recursion for below
        function searchDown(i) {

            // Check if below position is Fuc
            if (i < n.data.children.length && n.data.children[i].linkRegion > 0) {

                // Move new monosaccharid  downwards
                i++;

                // Recursively go upwards
                searchDown(i);

            }

            // Below lowest Fuc
            return i;
        }

        
        for (let [i, d] of n.data.children.entries()) {

            // New monosaccharid is just below this child
            if (d.y > sacObj.y) {

                // Check if above position is Fuc
                if (n.data.children[i - 1] && n.data.children[i - 1].linkRegion < 0) {

                    // Move new monosaccharid upwards
                    i = searchUp(i);
                }

                // Check if below position is Fuc
                else if (n.data.children[i].linkRegion > 0) {

                    // Move new monosaccharid downwards
                    i = searchDown(i);
                }

                // Insert monosaccharidat this position to glycan data
                n.data.children.splice(i, 0, sacObj);
                inserted = true;
                break;
            }
        }

        // If new monosaccharid is not inserted...
        if (!inserted) {

            // ... just append it at the end
            n.data.children.push(sacObj);
        }

    }

    // Render glycan
    canvas.glycan.render();

    return;
}
//****************************************************************************************
// GLYCOdraw: Workspace for drawing the glycan
//****************************************************************************************
/* global d3 */
/* global GLYCO */

/**
 * Constructor of base glycan object
 * 
 * @param {string} [id] HTML id of div that contains the svg glycan
 * @param {number=} height SVG height
 * @param {number=} width SVG width
 * @param {string=} theme Black or white theme
 * @returns {object} draw
 * */
GLYCO.draw = function (id, height, width, theme = "white") {

    // Base properties
    this.id = id || this.id;
    this.svg = null;
    this.meta = null;
    this.defs = null;
    this.width = null;
    this.height = null;
    this.theme = theme;

    // Set dimensions
    this.margin = 15;
    this.aspectRatio = 1.618;
    this.toolbarHeight = 510;

    // Height and width
    this.width = width || d3.select(id).node().clientWidth - (2 * this.margin);
    if (this.width < 0) this.width = 0;
    if (height) {
        this.height = height;
        this.aspectRatio = this.width / this.height;
    } else {
        this.height = Math.floor(this.width / this.aspectRatio);
    }

    // Components
    this.toolbar = null;
    this.canvas = null;
    this.glycan = null;

    // Render the svg
    // --------------
    // select and create the svg container
    this.svg = d3.select(this.id).append("svg")
        .attr("xmlns", "http://www.w3.org/2000/svg")
        .attr("xmlns:xlink", "http://www.w3.org/1999/xlink")
        .attr("version", "1.1")
        .attr("baseProfile", "full")
        .attr("width", this.width)
        .attr("height", this.height);

    // Set meta information e.g. styles (CSS)
    this.meta = this.svg.append("g")
        .attr("class", "meta")
        .attr("id", "meta");

    // Set background
    this.meta.append("rect")
        .attr("width", this.width)
        .attr("height", this.height)
        .attr("pointer-events", "all")
        .style("fill", this.theme);

    // Set title of svg
    this.meta.append("title")
        .text("GLYCOdraw");

    // Set description of svg
    this.meta.append("desc")
        .text("A JavaScript library to draw glycan structures.");

    // Set svg styles
    this.meta.append("style")
        .text(
`text {
    font-family: Segoe UI, -apple - system, Roboto, Helvetica Neue, Arial, sans - serif;
}
.sac {
    cursor: pointer;
}
.sac:hover {
    stroke-width: 2;
    overflow: visible;
}
.button {
    cursor: pointer;
}
.button:hover:not(.selected) {
    fill-opacity: 0.125 !important;
}`);



    // Initialise components
    //this.renderDefs();
    this.toolbar = new GLYCO.toolbar(this.svg);
    this.canvas = new GLYCO.canvas(this.svg, this.width, this.height, this.toolbar);

    // ##### TODO download
    this.toolbar.file.selectAll("#download > *")
        .on("click", () => this.canvas.glycan.download());

    return this;
}

// ###### currently not used #####

/**
 * Render defs in draw
 * 
 * @returns {object} draw
 * */
GLYCO.draw.prototype.renderDefs = function () {
    var draw = this;

    // Create defs object
    draw.defs = draw.svg.append("defs");

    // Add monosaccharide symbols zu defs
    var gSacs = draw.defs.append("g")
        .attr("id", "defSac");

    // Add a symbol for each monosaccharide to defs
    for (const [key, value] of Object.entries(GLYCO.typeEnum)) {

        // Add group for each monosaccharide
        let symbol = gSacs.append("g");

        // Set id
        symbol.attr("id", "def_" + key);

        // Append symbol
        switch (value) {
            case GLYCO.typeEnum.redEnd:
                symbol.append("circle")
                    .attr("r", GLYCO.sacSize / 4)
                    .attr("cx", GLYCO.sacSize / 2)
                    .attr("cy", GLYCO.sacSize / 2)
                    .style("stroke", "#888");
                break;
            case GLYCO.typeEnum.Hex:
                symbol.append("circle")
                    .attr("r", GLYCO.sacSize / 2)
                    .attr("cx", GLYCO.sacSize / 2)
                    .attr("cy", GLYCO.sacSize / 2)
                    .style("stroke", "#888");
                break;
            case GLYCO.typeEnum.HexNAc:
            case GLYCO.typeEnum.HexN:
            case GLYCO.typeEnum.HexA: {
                symbol.append("rect")
                    .attr("width", GLYCO.sacSize)
                    .attr("height", GLYCO.sacSize)
                    .style("stroke", "#888");
                if (value == GLYCO.typeEnum.HexNAc) break;

                // HexN
                // HexA
                // p1         y1
                // |  \ 
                // |     \
                // p2_____p3  y2
                // x1     x2
                const
                    x1 = 0,
                    x2 = y2 = GLYCO.sacSize,
                    y1 = 0,
                    p1 = x1 + " " + y1,
                    p2 = x1 + " " + y2,
                    p3 = x2 + " " + y2,
                    p = p1 + ", " + p2 + ", " + p3;
                symbol.append("polygon")
                    .attr("points", p)
                    .attr("fill", "#FFFFFF")
                    .style("stroke", "#888");
                if (value == GLYCO.typeEnum.HexN) break;

                // HexA
                symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 2}) rotate(-45) scale(${1 / Math.sqrt(2)})`);
                break;
            }
            case GLYCO.typeEnum.dHex:
            case GLYCO.typeEnum.dHexNAc: {
                //    p1     y1
                //   /|\ 
                //  / | \
                // p2_p4_p3  y2
                // x1 x2 x3
                const
                    h = Math.sqrt(3) * GLYCO.sacSize / 2
                x1 = 0,
                    x2 = GLYCO.sacSize / 2,
                    x3 = GLYCO.sacSize,
                    y1 = 0,//(GLYCO.sacSize - h) / 2,
                    y2 = h, //GLYCO.sacSize - (GLYCO.sacSize - h) / 2,
                    p1 = x2 + " " + y1,
                    p2 = x1 + " " + y2,
                    p3 = x3 + " " + y2,
                    p4 = x2 + " " + y2,
                    p = p1 + ", " + p2 + ", " + p3;
                symbol.append("rect")
                    .attr("width", GLYCO.sacSize)
                    .attr("height", GLYCO.sacSize)
                    .attr("fill", "none");
                symbol.append("polygon")
                    .attr("points", p)
                    .style("stroke", "#888");
                if (value == GLYCO.typeEnum.dHex) break;

                // dHexNAc
                symbol.append("polygon")
                    .attr("points", p1 + ", " + p2 + ", " + p4)
                    .attr("fill", "#FFFFFF")
                    .style("stroke", "#888");
                break;
            }
            case GLYCO.typeEnum.ddHex:
                symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 4})`);
                symbol.append("rect")
                    .attr("width", GLYCO.sacSize)
                    .attr("height", GLYCO.sacSize / 2)
                    .style("stroke", "#888");
                break;
            case GLYCO.typeEnum.Pent: {
                // Get points for star
                var r1 = GLYCO.sacSize / 2;
                var r2 = r1 / 2;
                var radP = []
                for (var p = 0; p < 11; p++) {
                    if (p % 2 == 0) {
                        radP[p] = [Math.PI * 0.2 * p, r1];
                    } else {
                        radP[p] = [Math.PI * 0.2 * p, r2];
                    }
                }
                var lRad = d3.radialLine();
                symbol.attr("transform", `translate(${GLYCO.sacSize / 2}, ${GLYCO.sacSize / 2})`);
                symbol.append("path")
                    .attr("d", lRad(radP))
                    .style("stroke", "#888");
                break;
            }
            case GLYCO.typeEnum.Sia:
                symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 2}) rotate(-45) scale(${1 / Math.sqrt(2)})`);
                symbol.append("rect")
                    .attr("width", GLYCO.sacSize)
                    .attr("height", GLYCO.sacSize)
                    .style("stroke", "#888");
                break;
        }
    }

    return draw;
}


GLYCO.draw.prototype.dragstarted = function (event, d) {
    var draw = this;

    // Clone monosaccharid to add to glycan
    var sacObj = new GLYCO.sac(d.sacEnum);

    // Set cloning position
    sacObj.pos = {
        x: d.pos.x,
        y: d.pos.y - draw.toolbarHeight
    }
    var sac = sacObj.render(draw.canvas.glycan.g);

    // Make symbol transparent for pointer events to detect drag over
    sac.selectAll("*").attr("pointer-events", "none");

    // Set global flag for dragging
    GLYCO.dragging = true;

    // it's important that we suppress the mouseover event on the node being dragged.
    // Otherwise it will absorb the mouseover event and the underlying node will not detect it
    // event.sourceEvent.stopPropagation();

    // Drag clone to glycan
    event.on("drag", function (event, d) { draw.dragged(event, d, draw, sac, sacObj) });

    // When finaly dragging has ended
    event.on("end", function (event, d) { draw.dragended(event, d, draw, sac, sacObj) });

    return sac;
}

GLYCO.draw.prototype.dragged = function (event, d, draw, sac, sacObj) {
    sacObj.pos.x += event.dx;
    sacObj.pos.y += event.dy;
    sac.attr("transform", "translate(" + (sacObj.pos.x) + ", " + (sacObj.pos.y) + ")");
}

GLYCO.draw.prototype.dragended = function (event, d, draw, sac, sacObj) {

    // Remove global flagg for dragging
    GLYCO.dragging = false;

    // Don't add monosaccharide, if no well is reached
    if (!draw.canvas.dragTarget) {
        sac.remove();
        return;
    }

    // Set target cell
    sacObj.cell = d3.select(draw.canvas.dragTarget).data()[0];

    // reset dragTarget
    draw.canvas.dragTarget = null;

    // Join sac to glycan
    draw.canvas.joinSac(sacObj);

    return;
}
//****************************************************************************************
// GLYCOglycan: Complete glycan structure
//
// A glycan is a grid with monosaccaride object in cells
//****************************************************************************************
/* global d3 */
/* global GLYCO */

/**
 * Constructor of base glycan object
 * 
 * @param {Object} [canvas] Canvas object
* @param {Object} [origin] Root of glycan tree
 * @returns {object} Glycan
 * */
GLYCO.glycan = function (canvas, origin) {

    // SVG objects
    this.canvas = canvas || this.canvas;
    this.g = null;
    this.origin = origin;

    // Glycan data
    let originX = this.canvas.scales.x(this.canvas.domains.x[1]);
    let originY = this.canvas.scales.y(this.canvas.domains.y[1] / 2);
    this.data = new GLYCO.sac(GLYCO.sacEnum.redEnd.redEnd, null, originX, originY);
    this.data.children.push(new GLYCO.sac(GLYCO.sacEnum.HexNAc.GlcNAc, this.data));
    this.tree = data => {
        return d3.tree().nodeSize([1, 1])(d3.hierarchy(data));
    };
    this.root = this.tree(this.data);

    // Initialise glycan
    // Create svg objects
    this.g = this.canvas.g.append("svg")
        .attr("id", "glycan");
    this.l = this.g.append("g")
        .attr("id", "linkages")
        .style('stroke', '#888')
        .style('stroke-width', '3px');

    return this;
}

GLYCO.glycan.prototype.render = function () {
    var glycan = this;

    // Add new data to glycan root
    glycan.root = d3.tree()(d3.hierarchy(glycan.data));

    // Update separation for proper positioning of Fuc. Read about separation: https://github.com/d3/d3-hierarchy#tree_separation
    glycan.root = d3.tree().separation((a, b) => {

        // All nodes with the same column (equal depth)
        let cousins = glycan.root.descendants().filter(d => d.depth == b.depth);
        let index = cousins.findIndex(c => c.data === b.data);

        // Check if its Fuc in upper position
        if (b.data.linkRegion < 0) {

            // Check if there is nothing else than Fuc on top
            function searchUp(i) {
                if (i == 0) {
                    return b.data.isEdge = true;
                } else if (cousins[i - 1].data.linkRegion < 0) {
                    i--;
                    return cousins[i].data.isEdge = searchUp(i);
                } else {
                    return b.data.isEdge = false;
                }
            }

            // Recursively search up
            return searchUp(index) ? 0 : 1;
        }

        // Check if its Fuc in lower position
        if (a.data.linkRegion > 0) {

            // Check if there is nothing else than Fuc below
            function searchDown(i) {
                if (i == cousins.length - 1) {
                    return a.data.isEdge = true;
                } else if (cousins[i + 1].data.linkRegion > 0) {
                    i++;
                    return cousins[i].data.isEdge = searchDown(i);
                } else {
                    return a.data.isEdge = false;
                }
            }

            // Recursively search down
            return searchDown(index) ? 0 : 1;
        }

        // All other situations
        return 1;
    }).nodeSize([1, 1])(d3.hierarchy(glycan.data));

    // Draw monosaccharides at their origin position
    draw();

    // Set final position
    glycan.root.descendants().forEach(d => glycan.setPosition(d));

    // Update positions with transition
    draw();

    function draw() {
        // Render links
        glycan.l.selectAll("line.linkage")
            .data(glycan.root.descendants().slice(1).sort((a, b) => a.data.id - b.data.id))
            .join(
                enter => enter.append("line")
                    .attr("class", "linkage")
                    .attr("x1", d => d.data.x + (GLYCO.sacSize / 2))
                    .attr("y1", d => d.data.y + (GLYCO.sacSize / 2))
                    .attr("x2", d => d.data.parent.x + (GLYCO.sacSize / 2))
                    .attr("y2", d => d.data.parent.y + (GLYCO.sacSize / 2))
                    .attr("clip-path", "url(#canvasClipPath)"),
                update => update.call(update => update.transition()
                    .attr("x1", d => d.data.x + (GLYCO.sacSize / 2))
                    .attr("y1", d => d.data.y + (GLYCO.sacSize / 2))
                    .attr("x2", d => d.data.parent.x + (GLYCO.sacSize / 2))
                    .attr("y2", d => d.data.parent.y + (GLYCO.sacSize / 2))
                ),
                exit => exit.remove()
            );

        // Render monosaccharides
        glycan.g.selectAll(".sac")
            .data(glycan.root.descendants().sort((a, b) => a.data.id - b.data.id))
            .join(
                enter => enter.append(d => d.data.render(glycan.g).node())
                    .call(d3.drag().on("start", (event, d) => glycan.canvas.dragstarted(event, d)))
                    .attr("pointer-events", "none"),
                update => update.call(update => update.transition()
                    .attr("transform", d => `translate(${d.data.x}, ${d.data.y})`)
                    .attr("pointer-events", "none")
                    .on("end", () => update.attr("pointer-events", null))
                    ),
                exit => exit.remove()
            );

    }

    return glycan;
}

GLYCO.glycan.prototype.setPosition = function (node) {
    var glycan = this;

    // Let D3 calculate x position
    node.data.x = glycan.canvas.scales.x(-node.y + glycan.canvas.domains.x[1]);

    // Fuc on edges needs additional distance
    if (node.data.isEdge) {

        // Get index of node in siblings
        let i = node.parent.children.findIndex(c => c === node);

        // Get neighbouring position
        // Get relative position to sister
        let x = node.parent.children.length > 1 ? node.parent.children[i - node.data.linkRegion].x : node.x;

        // ###### TODO ###### for consecutive Fuc add y for each
        node.data.y = glycan.canvas.scales.y(node.x + node.data.linkRegion + glycan.canvas.domains.y[1] / 2);

    } else {

        // All the others in normal positon
        node.data.y = glycan.canvas.scales.y(node.x + glycan.canvas.domains.y[1] / 2);

    }

    return glycan;
}

/**
 * Make a download for the chart as *.svg
 * 
 * @param {string} filename OPTIONAL Name of download file
 * @return {object} Chart
 */
GLYCO.glycan.prototype.download = function (filename) {
    var glycan = this;

    // Make filename and suffix optional
    filename = filename || "Glycan.svg";
    var suffix = ".svg";
    if (filename.indexOf(suffix, filename.length - suffix.length) === -1) {
        filename += ".svg";
    }

    // get svg source.
    var serializer = new XMLSerializer();
    var source = serializer.serializeToString(glycan.g.node());

    // add name spaces.
    if (!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if (!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)) {
        source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
    }

    // add xml declaration
    source = '<?xml version="1.0" encoding="UTF-8" standalone="no"?>' + source;

    // Make a blob with the correct type header
    var blob = new Blob([source], { type: "image/svg+xml;charset=utf-8" });
    if (window.navigator.msSaveOrOpenBlob) {
        window.navigator.msSaveBlob(blob, filename);
    }
    else {

        // Create an anchor element to the svg blob and remove it after download
        var element = window.document.createElement('a');
        element.href = window.URL.createObjectURL(blob);
        element.download = filename;
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
        window.URL.revokeObjectURL(element.href);
    }

    return glycan;
};

//****************************************************************************************
// GLYCOdraw    Copyright 2020 | Roland Josuran
//****************************************************************************************
var GLYCO = GLYCO || {
    sacSize: 28,
    fontSize: 14,
    idCount: 0,
    sacEnum: Object.freeze({
        redEnd: Object.freeze({ redEnd: 00}),
        Hex: Object.freeze({ Glc: 11, Man: 12, Gal: 13, Gul: 14, Alt: 15, All: 16, Tal: 17, Ido: 18 }),
        HexNAc: Object.freeze({ GlcNAc: 21, ManNAc: 22, GalNAc: 23, GulNAc: 24, AltNAc: 25, AllNAc: 26, TalNAc: 27, IdoNAc: 28 }),
        HexN: Object.freeze({ GlcN: 31, ManN: 32, GalN: 33, GulN: 34, AltN: 35, AllN: 36, TalN: 37, IdoN: 38 }),
        HexA: Object.freeze({ GlcA: 41, ManA: 42, GalA: 43, GulA: 44, AltA: 45, AllA: 46, TalA: 47, IdoA: 48 }),
        dHex: Object.freeze({ Qui: 51, Rha: 52, dGal: 53, dGul: 54, dAlt: 55, dAll: 56, dTal: 57, dIdo: 58, Fuc: 59 }),
        dHexNAc: Object.freeze({ QuiNAc: 61, RhaNAc: 62, dGalNAc: 63, dGulNAc: 64, dAltNAc: 65, dAllNAc: 66, dTalNAc: 67, dIdoNAc: 68, FucNAc: 69 }),
        ddHex: Object.freeze({Oli: 71, Tyv: 72, Abe: 74, Par: 75, Dig: 76, Col: 77 }),
        Pent: Object.freeze({ Ara: 82, Lyx: 83, Xyl: 84, Rib: 85 }),
        Sia: Object.freeze({ Kdn: 92, Neu5Ac: 96, Neu5Gc: 97, Neu: 98, Sia: 99 })
    }),
    typeEnum: Object.freeze({
        redEnd: 0,
        Hex: 1,
        HexNAc: 2,
        HexN: 3,
        HexA: 4,
        dHex: 5,
        dHexNAc: 6,
        ddHex: 7,
        Pent: 8,
        Sia: 9
    }),
    sym: Object.freeze(
        [
            ["redEnd"],
            ["Hex", "Glc", "Man", "Gal", "Gul", "Alt", "All", "Tal", "Ido", ""],
            ["HexNAc", "GlcNAc", "ManNAc", "GalNAc", "GulNAc", "AltNAc", "AllNAc", "TalNAc", "IdoNAc", ""],
            ["HexN", "GlcN", "ManN", "GalN", "GulN", "AltN", "AllN", "TalN", "IdoN", ""],
            ["HexA", "GlcA", "ManA", "GalA", "GulA", "AltA", "AllA", "TalA", "IdoA", ""],
            ["dHex","Qui", "Rha", "", "dGul", "dAlt", "", "dTal", "", "Fuc"],
            ["dHexNAc", "QuiNAc", "RhaNAc", "", "", "dAltNAc", "", "dTalNAc", "", "FucNAc"],
            ["ddHex", "Oli", "Tyv", "", "Abe", "Par", "Dig", "Col", "", ""],
            ["Pent", "", "Ara", "Lyx", "Xyl", "Rib", "", "", "", ""],
            ["Sia", "", "Kdn", "", "", "", "Neu5Ac", "Neu5Gc", "Neu", "Sia"],
            [
                "#FFFFFF",  // white https://www.ncbi.nlm.nih.gov/glycans/snfg.html
                "#0072BC",  // blue
                "#00A651",  // green
                "#FFD400",  // yellow
                "#F47920",  // orange
                "#F69EA1",  // altrose
                "#A54399",  // purple
                "#8FCCE9",  // light blue
                "#A17A4D",  // brown
                "#ED1C24"   // red
            ]
        ]),
    getType: function (sacEnum) {
        return this.sym[~~((sacEnum / 10) % 10)][0];
    },
    getSym: function (sacEnum) {
        return this.sym[~~((sacEnum / 10) % 10)][~~(sacEnum % 10)];
    },
    getColor: function (sacEnum) {
        return this.sym[10][~~(sacEnum % 10)];
    }
};

///**
// * Monosaccharide type enum
// **/
//GLYCO.prototype.sacEnum = Object.freeze({
//    Hex: Object.freeze({ Glc: 11, Man: 12, Gal: 13, Gul: 14, Alt: 15, All: 16, Tal: 17, Ido: 18 }),
//    HexNAc: Object.freeze({ GlcNAc: 21, ManNAc: 22, GalNAc: 23, GulNAc: 24, AltNAc: 25, AllNAc: 26, TalNAc: 27, IdoNAc: 28 }),
//    HexN: Object.freeze({ GlcN: 31, ManN: 32, GalN: 33, GulN: 34, AltN: 35, AllN: 36, TalN: 37, IdoN: 38 }),
//    HexA: Object.freeze({ GlcA: 41, ManA: 42, GalA: 43, GulA: 44, AltA: 45, AllA: 46, TalA: 47, IdoA: 48 }),
//    dHex: Object.freeze({ Qui: 51, Rha: 52, dGal: 53, dGul: 54, dAlt: 55, dAll: 56, dTal: 57, dIdo: 58, Fuc: 59 }),
//    dHexNAc: Object.freeze({ QuiNAc: 61, RhaNAc: 62, dGalNAc: 63, dGulNAc: 64, dAltNAc: 65, dAllNAc: 66, dTalNAc: 67, dIdoNAc: 68, FucNAc: 69 }),
//    ddHex: 70,
//    Pent: Object.freeze({ Ara: 82, Lyx: 83, Xyl: 84, Rib: 85 }),
//    Sia: Object.freeze({ Kdn: 92, Neu5Ac: 96, Neu5Gc: 97, Neu: 98, Sia: 99 })
//});

///**
// * Monosaccharide symbol array
// * */
//GLYCO.prototype.sym = []; 

//****************************************************************************************
// GLYCOdraw symbols for monosaccharide representation
//****************************************************************************************
/* global d3 */
/* global GLYCO */
/**
 * Constructor of base monosaccharide object
 * 
 * @param {GLYCO.sacEnum} [sacEnum] Enum type for monosaccharide
 * @param {GLYCO.sac} [parent] Parent monosaccharid
 * @param {number=} [x] Optional x coordinate
 * @param {number=} [y] Optional y coordinate
 * @returns {object} Monosaccharide
 * */
GLYCO.sac = function (sacEnum, parent, x, y) {

    // Base properties
    this.sacEnum = sacEnum;
    this.symbol = GLYCO.getSym(sacEnum);
    this.color = GLYCO.getColor(sacEnum);
    this.id = GLYCO.idCount++;
    this.parent = parent;
    this.children = new Array();
    this.target = null;
    this.x = isNaN(x) ? parent.x : x;
    this.y = isNaN(y) ? parent.y : y;
    this.linkRegion = sacEnum == GLYCO.sacEnum.dHex.Fuc || sacEnum == GLYCO.sacEnum.Pent.Xyl ? -1 : 0;
    this.isEdge = false;
    this.selected = false;
 
    return this;
}

/**
 * Render monosaccharid
 * 
 * @param {object} [target] d3.js selection of target
 * @returns {object} Monosaccharid
 */
GLYCO.sac.prototype.render = function (target) {
    var sac = this;

    // Set node to append
    sac.target = target;

    // Make a group for the symbol
    var g = sac.target
        .append("g")
        .attr("id", sac.symbol + "_" + sac.id)
        .attr("class",  "sac " + sac.symbol)
        .attr("transform", `translate(${sac.x}, ${sac.y})`)
        .attr("clip-path", "url(#canvasClipPath)");

    // Append symbol
    symbol = g.append("g")
        .attr("fill", sac.color);

    // Check if AllA or IdoA for mirroring upsidedown
    if (sac.sacEnum == GLYCO.sacEnum.HexA.AllA || sac.sacEnum == GLYCO.sacEnum.HexA.IdoA) {
        symbol.append("g").attr("transform", `translate(0, ${GLYCO.sacSize}) scale(1, -1)`);
    }

    //// Append defs of symbol shape
    //symbol.append("use")
    //    .attr("xlink:href", "#def_" + GLYCO.getType(sac.sacEnum));

    // Get monosaccharide type
    let type = Math.floor((sac.sacEnum / 10) % 10);

    // Append symbol
    switch (type) {
        case GLYCO.typeEnum.redEnd:
            symbol.append("circle")
                .attr("r", GLYCO.sacSize / 4)
                .attr("cx", GLYCO.sacSize / 2)
                .attr("cy", GLYCO.sacSize / 2)
                .style("stroke", "#888");
            break;
        case GLYCO.typeEnum.Hex:
            symbol.append("circle")
                .attr("r", GLYCO.sacSize / 2)
                .attr("cx", GLYCO.sacSize / 2)
                .attr("cy", GLYCO.sacSize / 2)
                .style("stroke", "#888");
            break;
        case GLYCO.typeEnum.HexNAc:
        case GLYCO.typeEnum.HexN:
        case GLYCO.typeEnum.HexA: {
            symbol.append("rect")
                .attr("width", GLYCO.sacSize)
                .attr("height", GLYCO.sacSize)
                .style("stroke", "#888");
            if (type == GLYCO.typeEnum.HexNAc) break;

            // HexN
            // HexA
            // p1         y1
            // |  \ 
            // |     \
            // p2_____p3  y2
            // x1     x2
            const
                x1 = 0,
                x2 = y2 = GLYCO.sacSize,
                y1 = 0,
                p1 = x1 + " " + y1,
                p2 = x1 + " " + y2,
                p3 = x2 + " " + y2,
                p = p1 + ", " + p2 + ", " + p3;
            symbol.append("polygon")
                .attr("points", p)
                .attr("fill", "#FFFFFF")
                .style("stroke", "#888");
            if (type == GLYCO.typeEnum.HexN) break;

            // HexA
            symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 2}) rotate(-45) scale(${1 / Math.sqrt(2)})`);
            break;
        }
        case GLYCO.typeEnum.dHex:
        case GLYCO.typeEnum.dHexNAc: {
            //    p1     y1
            //   /|\ 
            //  / | \
            // p2_p4_p3  y2
            // x1 x2 x3
            const
                h = Math.sqrt(3) * GLYCO.sacSize / 2
            x1 = 0,
                x2 = GLYCO.sacSize / 2,
                x3 = GLYCO.sacSize,
                y1 = 0,//(GLYCO.sacSize - h) / 2,
                y2 = h, //GLYCO.sacSize - (GLYCO.sacSize - h) / 2,
                p1 = x2 + " " + y1,
                p2 = x1 + " " + y2,
                p3 = x3 + " " + y2,
                p4 = x2 + " " + y2,
                p = p1 + ", " + p2 + ", " + p3;
            symbol.append("rect")
                .attr("width", GLYCO.sacSize)
                .attr("height", GLYCO.sacSize)
                .attr("fill", "none");
            symbol.append("polygon")
                .attr("points", p)
                .style("stroke", "#888");
            if (type == GLYCO.typeEnum.dHex) break;

            // dHexNAc
            symbol.append("polygon")
                .attr("points", p1 + ", " + p2 + ", " + p4)
                .attr("fill", "#FFFFFF")
                .style("stroke", "#888");
            break;
        }
        case GLYCO.typeEnum.ddHex:
            symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 4})`);
            symbol.append("rect")
                .attr("width", GLYCO.sacSize)
                .attr("height", GLYCO.sacSize / 2)
                .style("stroke", "#888");
            break;
        case GLYCO.typeEnum.Pent: {
            // Get points for star
            var r1 = GLYCO.sacSize / 2;
            var r2 = r1 / 2;
            var radP = []
            for (var p = 0; p < 11; p++) {
                if (p % 2 == 0) {
                    radP[p] = [Math.PI * 0.2 * p, r1];
                } else {
                    radP[p] = [Math.PI * 0.2 * p, r2];
                }
            }
            var lRad = d3.radialLine();
            symbol.attr("transform", `translate(${GLYCO.sacSize / 2}, ${GLYCO.sacSize / 2})`);
            symbol.append("path")
                .attr("d", lRad(radP))
                .style("stroke", "#888");
            break;
        }
        case GLYCO.typeEnum.Sia:
            symbol.attr("transform", `translate(0, ${GLYCO.sacSize / 2}) rotate(-45) scale(${1 / Math.sqrt(2)})`);
            symbol.append("rect")
                .attr("width", GLYCO.sacSize)
                .attr("height", GLYCO.sacSize)
                .style("stroke", "#888");
            break;
    }


    // Return group with rendered monosaccharid
    return g;
}

//****************************************************************************************
// GLYCOtoolbar: Toolbar for drawing
//****************************************************************************************
/* global d3 */
/* global GLYCO */

/**
 * Constructor of toolbar
 * @param {object} [svg] d3 selection of svg container
 * @returns {object} toolbar
 * */
GLYCO.toolbar = function (svg) {

    // Dimension
    this.svg = svg;
    this.g = null;
    this.sacTable = null;
    this.file = null;
    this.padding = {
        x: 15,
        y: 5
    }
    this.cols = GLYCO.sym[10].length;
    this.rows = GLYCO.sym.length - 1;
    this.cellWidth = GLYCO.sacSize + 2 * this.padding.x;
    this.cellHeight = GLYCO.sacSize + GLYCO.fontSize * 1.2 + 2 * this.padding.y;
    this.height = this.rows * this.cellHeight;


    // Generate data for toolbar rendering
    this.data = this.getGrid();

    // Toolbar button clicked
    this.selected = null;

    // Render toolbar
    // ---------------
    // Add group for toolbar
    this.g = this.svg.append("g")
        .attr("id", "toolbar");

    // File menu
    // --------------------
    this.file = this.g.append("g")
        .attr("id", "download")
        .attr("transform", `translate(${this.cols * this.cellWidth}, 0)`);
    this.file.append("text")
        .text("Save")
        .attr("x", this.cellWidth / 2)
        .attr("y", this.cellHeight / 2)
        .attr("font-size", GLYCO.fontSize)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .style("fill", "#888");
    this.file.append("rect")
        .attr("class", "button")
        .attr("width", this.cellWidth)
        .attr("height", this.cellHeight)
        .style("stroke", "#888")
        .style("fill", "#888")
        .style("fill-opacity", 0);

    // Full palett of monosaccharides
    // --------------------
    this.sacTable = this.g.append("g")
        .attr("id", "sacTable");

    // Draw grid for buttons https://bl.ocks.org/cagrimmett/07f8c8daea00946b9e704e3efcbd5739
    var col = this.sacTable.selectAll(".col")
        .data(this.data)
        .enter().append("g")
        .attr("class", "col");
    var row = col.selectAll(".button")
        .data(function (d) {
            return d;
        })
        .enter();

    // Append cells
    cell = row.append("g")
        .attr("transform", function (d) {
            return `translate(${d.x}, ${d.y})`;
        })

    // Write name
    cell.append("text")
        .text(d => GLYCO.getSym(d.sacEnum))
        .attr("x", this.cellWidth / 2)
        .attr("y", this.cellHeight - this.padding.y)
        .attr("font-size", GLYCO.fontSize)
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "baseline")
        .style("fill", "#888");

    // Draw border
    cell.append("rect")
        .attr("class", d => d.selected ? "button selected" : "button")
        .attr("width", this.cellWidth)
        .attr("height", this.cellHeight)
        .style("stroke", "#888")
        .style("fill", "#888")
        .style("fill-opacity", 0)
        .on("click", (e, d) => this.select(e, d, this));

    // Create monosaccaride object
    this.sacTable.selectAll(".sac")
        .data(this.data.reduce((acc, val) => acc.concat(val), []))
        .enter()
        .append((d, i, n) => {
            d.x += this.padding.x;
            d.y += this.padding.y;
            return d.render(d3.select(n[i])).node();
        })
        .attr("pointer-events", "none");

    return this;
}

/**
 * Get grid data
 * 
 * @returns {Array} Grid data 
 * */
GLYCO.toolbar.prototype.getGrid = function () {
    var toolbar = this;

    var data = new Array();
    var xpos = 0; //starting xpos and ypos at 1 so the stroke will show when we make the grid below
    var ypos = 0;

    // iterate for rows 
    for (var col = 0; col < toolbar.cols; col++) {
        data.push(new Array());

        // iterate for cells/columns inside rows
        for (var row = 0; row < toolbar.rows - 1; row++) {

            // Create monosaccharid an add to data array
            data[col].push(new GLYCO.sac((row) * 10 + col, null, xpos, ypos));

            // increment the x position. I.e. move it over by 50 (width variable)
            ypos += toolbar.cellHeight;
        }
        // reset the x position after a row is complete
        ypos = 0;
        // increment the y position for the next row. Move it down 50 (height variable)
        xpos += toolbar.cellWidth;
    }
    return data;
}

GLYCO.toolbar.prototype.select = function (e, d, toolbar) {
    var toolbar = toolbar;

    // Check if allready selected and revert
    if (d.selected) {
        d.selected = false;
        toolbar.selected = false;
        toolbar.sacTable.selectAll(".selected")
            .classed("selected", false)
            .style("fill-opacity", 0);
    } else {

        // Reset selected
        if (toolbar.selected) {
            toolbar.selected.selected = false;
            toolbar.selected = false;
            toolbar.sacTable.selectAll(".selected")
                .classed("selected", false)
                .style("fill-opacity", 0);
        }

        // Set selected monosaccharide
        d.selected = true;
        toolbar.selected = d;

        // Add class .selected
        d3.select(event.currentTarget)
            .classed("selected", true)
            .style("fill-opacity", 0.25);
    }

    return toolbar;
}